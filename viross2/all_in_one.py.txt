#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Viros Mitm - TÃ¼mÃ¼ Bir Arada SÃ¼rÃ¼m
GeliÅŸmiÅŸ ARP Spoofing Tespit AracÄ±

Bu dosya, Viros Mitm'in tÃ¼m bileÅŸenlerini tek bir dosyada birleÅŸtirir.
ARP tablosunu izler ve olasÄ± saldÄ±rÄ±larÄ± tespit eder.
Arka planda Ã§alÄ±ÅŸabilir ve zamanlanmÄ±ÅŸ taramalar yapabilir.
"""

import os
import sys
import time
import socket
import logging
import threading
import tempfile
import datetime
from pathlib import Path
import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import subprocess
import random
import platform
from PIL import Image, ImageTk

# --------------------------
# GÃ¼nlÃ¼k (Logging) AyarlarÄ±
# --------------------------

def setup_logging():
    """Uygulama iÃ§in gÃ¼nlÃ¼k (logging) sistemini yapÄ±landÄ±rÄ±r."""
    log_dir = os.path.join(os.path.expanduser("~"), ".viros_mitm", "logs")
    os.makedirs(log_dir, exist_ok=True)
    
    today = datetime.datetime.now().strftime("%Y%m%d")
    log_file = os.path.join(log_dir, f"viros_mitm_{today}.log")
    
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler()
        ]
    )
    
    logger = logging.getLogger("utils")
    logger.info(f"Viros Mitm started on {platform.platform()}")
    logger.info(f"Python version: {platform.python_version()}")
    logger.info(f"Log file: {log_file}")
    
    return logger

logger = setup_logging()

# --------------------------
# YardÄ±mcÄ± Ä°ÅŸlevler
# --------------------------

def is_admin():
    """UygulamanÄ±n yÃ¶netici haklarÄ±yla Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± kontrol eder."""
    try:
        if platform.system() == "Windows":
            import ctypes
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        else:
            return os.geteuid() == 0
    except:
        return False

def format_time_remaining(seconds):
    """Saniye cinsinden bir sÃ¼reyi insan tarafÄ±ndan okunabilir formata Ã§evirir."""
    if seconds < 60:
        return f"{seconds}s"
    elif seconds < 3600:
        minutes = seconds // 60
        return f"{minutes}m"
    else:
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        return f"{hours}h {minutes}m"

def clean_old_logs(max_days=7):
    """Belirtilen gÃ¼nden daha eski gÃ¼nlÃ¼k (log) dosyalarÄ±nÄ± temizler."""
    log_dir = os.path.join(os.path.expanduser("~"), ".viros_mitm", "logs")
    if not os.path.exists(log_dir):
        return
    
    now = datetime.datetime.now()
    for file in os.listdir(log_dir):
        if not file.startswith("viros_mitm_") or not file.endswith(".log"):
            continue
        
        file_path = os.path.join(log_dir, file)
        file_time = datetime.datetime.fromtimestamp(os.path.getmtime(file_path))
        if (now - file_time).days > max_days:
            try:
                os.remove(file_path)
                logger.info(f"Removed old log file: {file}")
            except Exception as e:
                logger.error(f"Failed to remove old log file {file}: {e}")

def get_temp_dir():
    """Uygulama iÃ§in geÃ§ici dizin oluÅŸturur ve yolunu dÃ¶ndÃ¼rÃ¼r."""
    temp_dir = os.path.join(tempfile.gettempdir(), "viros_mitm")
    os.makedirs(temp_dir, exist_ok=True)
    return temp_dir

# --------------------------
# ARP Tespit Ä°ÅŸlevleri
# --------------------------

def format_mac(mac_bytes):
    """Binary MAC adresini okunabilir formata Ã§evirir."""
    return ":".join([f"{b:02x}" for b in mac_bytes])

def format_ip(ip_bytes):
    """Binary IP adresini okunabilir formata Ã§evirir."""
    return ".".join([str(b) for b in ip_bytes])

def get_arp_table():
    """
    Sistemin ARP tablosunu alÄ±r.
    
    Returns:
        list: ARP tablosundaki kayÄ±tlar listesi
    """
    arp_table = []
    
    try:
        # GerÃ§ek bir sistemde, bu ARP tablosunu okuyacaktÄ±r
        # Replit ortamÄ±nda test iÃ§in simÃ¼le edilmiÅŸ veriler
        logger.warning("Using simulated ARP data for development")
        
        # SimÃ¼le edilmiÅŸ normal cihazlar
        arp_table.append({
            "ip": "192.168.1.1",
            "mac": "aa:bb:cc:dd:ee:ff",
            "interface": "eth0"
        })
        arp_table.append({
            "ip": "192.168.1.2",
            "mac": "11:22:33:44:55:66",
            "interface": "eth0"
        })
        arp_table.append({
            "ip": "192.168.1.3",
            "mac": "aa:bb:cc:11:22:33",
            "interface": "eth0"
        })
        arp_table.append({
            "ip": "192.168.1.4",
            "mac": "dd:ee:ff:11:22:33",
            "interface": "eth0"
        })
        
        # SimÃ¼le edilmiÅŸ ÅŸÃ¼pheli kayÄ±tlar
        arp_table.append({
            "ip": "192.168.1.1",  # Ã‡akÄ±ÅŸan IP (Gateway IP)
            "mac": "00:11:22:33:44:55",  # FarklÄ± MAC adresi
            "interface": "eth0"
        })
        arp_table.append({
            "ip": "192.168.1.5",
            "mac": "00:11:22:33:44:55",  # AynÄ± MAC (muhtemelen saldÄ±rganÄ±n)
            "interface": "eth0"
        })
        arp_table.append({
            "ip": "192.168.1.255",  # Broadcast adresi
            "mac": "ff:ff:ff:ff:ff:ff",
            "interface": "eth0"
        })
        
    except Exception as e:
        logger.error(f"Error getting ARP table: {e}")
    
    return arp_table

def get_default_gateway():
    """
    VarsayÄ±lan aÄŸ geÃ§idini (default gateway) bulur.
    
    Returns:
        dict: AÄŸ geÃ§idi IP ve MAC adresi
    """
    try:
        # GerÃ§ek bir sistemde, varsayÄ±lan aÄŸ geÃ§idini bulma kodu
        # Replit ortamÄ±nda test iÃ§in simÃ¼le edilmiÅŸ veriler
        logger.warning("Using simulated gateway data")
        return {
            "ip": "192.168.1.1",
            "mac": "aa:bb:cc:dd:ee:ff"
        }
    except Exception as e:
        logger.error(f"Error finding default gateway: {e}")
        return {
            "ip": "Unknown",
            "mac": "Unknown"
        }

def detect_arp_spoofing(arp_table):
    """
    ARP tablosunu inceleyerek olasÄ± ARP spoofing saldÄ±rÄ±larÄ±nÄ± tespit eder.
    
    Args:
        arp_table (list): ARP tablosu kayÄ±tlarÄ±
        
    Returns:
        list: Tespit edilen ÅŸÃ¼pheli durumlar
    """
    suspicious_entries = []
    gateway = get_default_gateway()
    
    # IP-MAC eÅŸleÅŸtirmelerini kontrol et
    ip_to_mac_map = {}
    
    # Broadcast adreslerini filtrele
    broadcast_macs = ["ff:ff:ff:ff:ff:ff"]
    
    for entry in arp_table:
        ip = entry["ip"]
        mac = entry["mac"]
        
        # Broadcast MAC'leri atla
        if mac.lower() in broadcast_macs:
            continue
            
        # Broadcast IP'leri atla (x.x.x.255)
        if ip.endswith(".255"):
            continue
        
        # AynÄ± IP iÃ§in birden fazla MAC adresi kontrolÃ¼
        if ip in ip_to_mac_map:
            if ip_to_mac_map[ip] != mac:
                suspicious_entries.append({
                    "severity": "critical",
                    "message": f"âŒ ARP Spoofing Tespit Edildi: {ip} IP iÃ§in birden fazla MAC: {ip_to_mac_map[ip]} ve {mac}"
                })
        else:
            ip_to_mac_map[ip] = mac
    
    # AynÄ± MAC adresi iÃ§in birden fazla IP kontrolÃ¼
    mac_to_ip_map = {}
    for entry in arp_table:
        mac = entry["mac"]
        ip = entry["ip"]
        
        # Broadcast MAC'leri atla
        if mac.lower() in broadcast_macs:
            continue
            
        # Broadcast IP'leri atla
        if ip.endswith(".255"):
            continue
        
        if mac in mac_to_ip_map:
            mac_to_ip_map[mac].append(ip)
        else:
            mac_to_ip_map[mac] = [ip]
    
    for mac, ips in mac_to_ip_map.items():
        if len(ips) > 3:  # 3'ten fazla IP adresi ÅŸÃ¼phelidir
            suspicious_entries.append({
                "severity": "warning",
                "message": f"âš ï¸ ÅÃ¼pheli MAC Adresi: {mac} - {len(ips)} farklÄ± IP adresine sahip"
            })
        elif len(ips) > 1:
            suspicious_entries.append({
                "severity": "info",
                "message": f"â„¹ï¸ Birden fazla IP'ye sahip MAC: {mac} - IP'ler: {', '.join(ips)}"
            })
    
    # AÄŸ geÃ§idi (gateway) MAC adresi deÄŸiÅŸiklikleri kontrolÃ¼
    gateway_ip = gateway["ip"]
    gateway_mac = gateway["mac"]
    
    for entry in arp_table:
        if entry["ip"] == gateway_ip and entry["mac"] != gateway_mac:
            suspicious_entries.append({
                "severity": "critical",
                "message": f"âŒ ARP Gateway Spoofing Tespit Edildi: GeÃ§it {gateway_ip} MAC adresi deÄŸiÅŸmiÅŸ. Beklenen: {gateway_mac}, Bulunan: {entry['mac']}"
            })
    
    return suspicious_entries

def perform_scan():
    """
    Tam bir ARP taramasÄ± ve analizi gerÃ§ekleÅŸtirir.
    ARP tablosu ve ÅŸÃ¼pheli giriÅŸleri iÃ§eren tarama sonuÃ§larÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.
    """
    logger.info("Starting ARP table scan...")
    
    try:
        # ARP tablosunu al
        arp_table = get_arp_table()
        
        # ÅÃ¼pheli giriÅŸleri tespit et
        suspicious_entries = detect_arp_spoofing(arp_table)
        
        # Gateway bilgisini al
        gateway = get_default_gateway()
        
        # Tarama sonuÃ§larÄ±nÄ± hazÄ±rla
        severity_counts = {
            "critical": 0,
            "warning": 0,
            "info": 0
        }
        
        # ÅÃ¼pheli giriÅŸleri sÄ±nÄ±flandÄ±r
        for entry in suspicious_entries:
            severity = entry.get("severity", "info")
            if severity in severity_counts:
                severity_counts[severity] += 1
        
        result = {
            "success": True,
            "timestamp": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "arp_table": arp_table,
            "suspicious_entries": suspicious_entries,
            "gateway": gateway,
            "severity_counts": severity_counts
        }
        
        logger.info(f"ARP scan completed: {len(arp_table)} entries, {len(suspicious_entries)} suspicious entries")
        return result
        
    except Exception as e:
        logger.error(f"Error performing ARP scan: {e}")
        return {
            "success": False,
            "error": str(e),
            "timestamp": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

# --------------------------
# ZamanlanmÄ±ÅŸ GÃ¶rev YÃ¶neticisi
# --------------------------

class ScheduleManager:
    """ZamanlanmÄ±ÅŸ taramalarÄ± esnek aralÄ±klarla yÃ¶netir."""
    
    def __init__(self, callback=None):
        """
        Zamanlama yÃ¶neticisini baÅŸlatÄ±r.
        
        Args:
            callback: ZamanlanmÄ±ÅŸ sÃ¼re dolduÄŸunda Ã§aÄŸrÄ±lacak fonksiyon
        """
        self.callback = callback
        self.active = False
        self.scheduler_thread = None
        self.interval = 1
        self.unit = "hour"
        self.next_run_time = None
        
    def start(self, interval=1, unit="hour"):
        """
        Belirtilen aralÄ±kla zamanlanmÄ±ÅŸ taramayÄ± baÅŸlatÄ±r.
        
        Args:
            interval: Zaman birimi sayÄ±sÄ±
            unit: 'minute' veya 'hour'
        """
        self.interval = interval
        self.unit = unit
        self.active = True
        
        # Mevcut zamanlayÄ±cÄ± varsa durdur
        if self.scheduler_thread and self.scheduler_thread.is_alive():
            self.stop()
        
        # Yeni zamanlayÄ±cÄ± baÅŸlat
        self.scheduler_thread = threading.Thread(target=self._scheduler_thread, daemon=True)
        self.scheduler_thread.start()
        
        logger.info(f"Scheduling started: every {interval} {unit}(s)")
        
    def stop(self):
        """ZamanlanmÄ±ÅŸ taramayÄ± durdurur."""
        self.active = False
        logger.info("Scheduling stopped")
        
    def update(self, interval, unit):
        """
        Zamanlama aralÄ±ÄŸÄ±nÄ± gÃ¼nceller.
        
        Args:
            interval: Zaman birimi sayÄ±sÄ±
            unit: 'minute' veya 'hour'
        """
        if self.active:
            self.interval = interval
            self.unit = unit
            logger.info(f"Schedule updated: every {interval} {unit}(s)")
            
    def is_active(self):
        """ZamanlamanÄ±n ÅŸu anda aktif olup olmadÄ±ÄŸÄ±nÄ± kontrol eder."""
        return self.active
        
    def get_interval_display(self):
        """GÃ¶rÃ¼ntÃ¼leme iÃ§in mevcut aralÄ±ÄŸÄ± alÄ±r."""
        return f"{self.interval} {self.unit}(s)"
        
    def get_next_run_time(self):
        """Bir sonraki Ã§alÄ±ÅŸtÄ±rma zamanÄ±nÄ± dize olarak alÄ±r."""
        if not self.next_run_time:
            return "Unknown"
        return self.next_run_time.strftime("%H:%M:%S")
        
    def _scheduler_thread(self):
        """Zamanlama mantÄ±ÄŸÄ±nÄ± iÅŸleyen iÅŸ parÃ§acÄ±ÄŸÄ± iÅŸlevi."""
        while self.active:
            # Bir sonraki Ã§alÄ±ÅŸma zamanÄ±nÄ± hesapla
            if self.unit == "minute":
                seconds = self.interval * 60
            else:  # hour
                seconds = self.interval * 3600
                
            self.next_run_time = datetime.datetime.now() + datetime.timedelta(seconds=seconds)
            
            # ZamanÄ± bekle
            for _ in range(seconds):
                if not self.active:
                    break
                time.sleep(1)
                
            # Hala aktifse ve bekleme tamamlandÄ±ysa callback'i Ã§aÄŸÄ±r
            if self.active and self.callback:
                try:
                    self.callback()
                except Exception as e:
                    logger.error(f"Error in scheduled callback: {e}")

# --------------------------
# Bildirim YÃ¶neticisi
# --------------------------

class NotificationManager:
    """Yedekleme seÃ§enekleriyle sistem bildirimlerini yÃ¶netir."""
    
    def __init__(self, app_name):
        """
        Bildirim yÃ¶neticisini baÅŸlatÄ±r.
        
        Args:
            app_name: Bildirimler iÃ§in uygulama adÄ±
        """
        self.app_name = app_name
        self.available_methods = self._detect_notification_methods()
        logger.info(f"Available notification methods: {self.available_methods}")
        
    def _detect_notification_methods(self):
        """
        Sistemde mevcut bildirim yÃ¶ntemlerini algÄ±lar.
        
        Returns:
            list: Mevcut bildirim yÃ¶ntemleri
        """
        methods = []
        
        # Windows bildirim yÃ¶ntemlerini kontrol et
        if platform.system() == "Windows":
            try:
                # win10toast modÃ¼lÃ¼nÃ¼ kontrol et
                try:
                    import win10toast
                    methods.append("win10toast")
                except ImportError:
                    pass
            except:
                pass
                
        # Linux bildirim yÃ¶ntemlerini kontrol et
        elif platform.system() == "Linux":
            try:
                # notify-send varlÄ±ÄŸÄ±nÄ± kontrol et
                try:
                    # notify-send varlÄ±ÄŸÄ±nÄ± kontrol et (sessizce)
                    with open(os.devnull, 'w') as devnull:
                        if subprocess.call(["which", "notify-send"], stdout=devnull, stderr=devnull) == 0:
                            methods.append("notify-send")
                        # zenity varlÄ±ÄŸÄ±nÄ± kontrol et
                        elif subprocess.call(["which", "zenity"], stdout=devnull, stderr=devnull) == 0:
                            methods.append("zenity")
                except:
                    pass
            except:
                pass
                
        # macOS bildirim yÃ¶ntemlerini kontrol et
        elif platform.system() == "Darwin":
            try:
                # osascript varlÄ±ÄŸÄ±nÄ± kontrol et (sessizce)
                with open(os.devnull, 'w') as devnull:
                    if subprocess.call(["which", "osascript"], stdout=devnull, stderr=devnull) == 0:
                        methods.append("applescript")
            except:
                pass
        
        # Her platformda Ã§alÄ±ÅŸan son Ã§are yÃ¶ntemi
        methods.append("balloontip")
        
        return methods
        
    def show_notification(self, title, message):
        """
        Mevcut en iyi yÃ¶ntemi kullanarak bildirim gÃ¶sterir.
        
        Args:
            title: Bildirim baÅŸlÄ±ÄŸÄ±
            message: Bildirim mesajÄ±
        """
        threading.Thread(
            target=self._show_notification_thread,
            args=(title, message),
            daemon=True
        ).start()
        
    def show_critical_notification(self, title, message):
        """
        Daha yÃ¼ksek gÃ¶rÃ¼nÃ¼rlÃ¼ÄŸe sahip kritik bir bildirim gÃ¶sterir.
        
        Args:
            title: Bildirim baÅŸlÄ±ÄŸÄ±
            message: Bildirim mesajÄ±
        """
        threading.Thread(
            target=self._show_notification_thread,
            args=(title, message, True),
            daemon=True
        ).start()
        
    def _show_notification_thread(self, title, message, critical=False):
        """
        Bildirim gÃ¶sterme iÅŸ parÃ§acÄ±ÄŸÄ± iÅŸlevi.
        
        Args:
            title: Bildirim baÅŸlÄ±ÄŸÄ±
            message: Bildirim mesajÄ±
            critical: Kritik bir bildirim olup olmadÄ±ÄŸÄ±
        """
        for method in self.available_methods:
            try:
                if method == "win10toast" and platform.system() == "Windows":
                    self._notify_win10toast(title, message, critical)
                    return
                elif method == "notify-send" and platform.system() == "Linux":
                    self._notify_linux(title, message, critical)
                    return
                elif method == "zenity" and platform.system() == "Linux":
                    self._notify_zenity(title, message, critical)
                    return
                elif method == "applescript" and platform.system() == "Darwin":
                    self._notify_macos(title, message, critical)
                    return
                elif method == "balloontip":
                    self._notify_balloontip(title, message, critical)
                    return
            except Exception as e:
                logger.error(f"Error showing notification with {method}: {e}")
                continue
                
        logger.warning("Failed to show notification with any method")
        
    def _notify_win10toast(self, title, message, critical=False):
        """Windows 10+ iÃ§in win10toast kullanarak bildirim gÃ¶sterir."""
        try:
            from win10toast import ToastNotifier
            toaster = ToastNotifier()
            toaster.show_toast(
                title,
                message,
                icon_path=None,
                duration=5 if not critical else 10,
                threaded=True
            )
        except Exception as e:
            logger.error(f"Error in win10toast notification: {e}")
            raise
            
    def _notify_balloontip(self, title, message, critical=False):
        """Son Ã§are olarak tkinter balon ipucu kullanarak bildirim gÃ¶sterir."""
        try:
            # En Ã¼stte bir tkinter penceresi oluÅŸtur ve gizle
            root = tk.Tk()
            root.withdraw()
            
            # EkranÄ±n kenarÄ±nda bir etiket konumlandÄ±r
            screen_width = root.winfo_screenwidth()
            screen_height = root.winfo_screenheight()
            
            label = tk.Label(root, text="ğŸ””", font=("Arial", 16), bg="black", fg="white")
            label.place(x=screen_width - 40, y=screen_height - 80)
            
            # Etiket Ã¼zerinde bir balon ipucu gÃ¶ster
            label.bind("<Enter>", lambda e: label.config(bg="darkgray"))
            label.bind("<Leave>", lambda e: label.config(bg="black"))
            
            import tkinter.messagebox as mb
            mb.showinfo(title, message)
            
            # Formu temizle
            root.destroy()
        except Exception as e:
            logger.error(f"Error in balloon tip notification: {e}")
            raise
            
    def _notify_linux(self, title, message, critical=False):
        """Linux'ta notify-send kullanarak bildirim gÃ¶sterir."""
        try:
            urgency = "critical" if critical else "normal"
            subprocess.call([
                "notify-send",
                "--app-name", self.app_name,
                "--urgency", urgency,
                title,
                message
            ])
        except Exception as e:
            logger.error(f"Error in Linux notification: {e}")
            raise
            
    def _notify_zenity(self, title, message, critical=False):
        """Linux'ta zenity kullanarak bildirim gÃ¶sterir."""
        try:
            info_type = "error" if critical else "info"
            subprocess.call([
                "zenity",
                f"--{info_type}",
                "--title", title,
                "--text", message
            ])
        except Exception as e:
            logger.error(f"Error in Zenity notification: {e}")
            raise
            
    def _notify_macos(self, title, message, critical=False):
        """macOS'ta AppleScript kullanarak bildirim gÃ¶sterir."""
        try:
            subprocess.call([
                "osascript",
                "-e", f'display notification "{message}" with title "{title}" sound name "{"Basso" if critical else "Submarine"}"'
            ])
        except Exception as e:
            logger.error(f"Error in macOS notification: {e}")
            raise

# --------------------------
# Otomatik BaÅŸlatma YÃ¶neticisi
# --------------------------

class AutoStartManager:
    """Sistem baÅŸlangÄ±cÄ±nda otomatik baÅŸlatmayÄ± yÃ¶netir."""
    
    def __init__(self, app_name):
        """
        Otomatik baÅŸlatma yÃ¶neticisini baÅŸlatÄ±r.
        
        Args:
            app_name: Uygulama adÄ±
        """
        self.app_name = app_name
        self.app_path = os.path.abspath(sys.argv[0])
        
    def enable(self):
        """
        Sistemle birlikte uygulamanÄ±n baÅŸlamasÄ±nÄ± etkinleÅŸtirir.
        
        Returns:
            bool: BaÅŸarÄ±lÄ±ysa True, deÄŸilse False
        """
        system = platform.system()
        if system == "Windows":
            return self._enable_windows()
        elif system == "Linux":
            return self._enable_linux()
        else:
            logger.warning(f"Autostart not supported on {system}")
            return False
            
    def disable(self):
        """
        Sistemle birlikte uygulamanÄ±n baÅŸlamasÄ±nÄ± devre dÄ±ÅŸÄ± bÄ±rakÄ±r.
        
        Returns:
            bool: BaÅŸarÄ±lÄ±ysa True, deÄŸilse False
        """
        system = platform.system()
        if system == "Windows":
            return self._disable_windows()
        elif system == "Linux":
            return self._disable_linux()
        else:
            logger.warning(f"Autostart not supported on {system}")
            return False
            
    def is_enabled(self):
        """
        UygulamanÄ±n sistemle birlikte baÅŸlamak Ã¼zere ayarlanÄ±p ayarlanmadÄ±ÄŸÄ±nÄ± kontrol eder.
        
        Returns:
            bool: EtkinleÅŸtirilmiÅŸse True, deÄŸilse False
        """
        system = platform.system()
        if system == "Windows":
            return self._is_enabled_windows()
        elif system == "Linux":
            return self._is_enabled_linux()
        else:
            logger.warning(f"Autostart not supported on {system}")
            return False
            
    def _enable_windows(self):
        """Windows'ta kayÄ±t defterini kullanarak otomatik baÅŸlatmayÄ± etkinleÅŸtirir."""
        try:
            import winreg
            key = winreg.OpenKey(
                winreg.HKEY_CURRENT_USER,
                r"Software\Microsoft\Windows\CurrentVersion\Run",
                0, winreg.KEY_SET_VALUE
            )
            winreg.SetValueEx(key, self.app_name, 0, winreg.REG_SZ, self.app_path)
            winreg.CloseKey(key)
            logger.info("Autostart enabled on Windows")
            return True
        except Exception as e:
            logger.error(f"Error enabling autostart on Windows: {e}")
            return False
            
    def _disable_windows(self):
        """Windows'ta kayÄ±t defteri giriÅŸini kaldÄ±rarak otomatik baÅŸlatmayÄ± devre dÄ±ÅŸÄ± bÄ±rakÄ±r."""
        try:
            import winreg
            key = winreg.OpenKey(
                winreg.HKEY_CURRENT_USER,
                r"Software\Microsoft\Windows\CurrentVersion\Run",
                0, winreg.KEY_SET_VALUE
            )
            try:
                winreg.DeleteValue(key, self.app_name)
            except:
                # DeÄŸer zaten yoksa yok sayÄ±labilir
                pass
            winreg.CloseKey(key)
            logger.info("Autostart disabled on Windows")
            return True
        except Exception as e:
            logger.error(f"Error disabling autostart on Windows: {e}")
            return False
            
    def _is_enabled_windows(self):
        """Windows'ta otomatik baÅŸlatmanÄ±n etkin olup olmadÄ±ÄŸÄ±nÄ± kontrol eder."""
        try:
            import winreg
            key = winreg.OpenKey(
                winreg.HKEY_CURRENT_USER,
                r"Software\Microsoft\Windows\CurrentVersion\Run",
                0, winreg.KEY_READ
            )
            try:
                value, _ = winreg.QueryValueEx(key, self.app_name)
                winreg.CloseKey(key)
                return value == self.app_path
            except:
                winreg.CloseKey(key)
                return False
        except Exception as e:
            logger.error(f"Error checking autostart status on Windows: {e}")
            return False
            
    def _enable_linux(self):
        """Linux'ta masaÃ¼stÃ¼ giriÅŸi kullanarak otomatik baÅŸlatmayÄ± etkinleÅŸtirir."""
        try:
            autostart_dir = os.path.expanduser("~/.config/autostart")
            os.makedirs(autostart_dir, exist_ok=True)
            
            desktop_file_path = os.path.join(autostart_dir, f"{self.app_name}.desktop")
            with open(desktop_file_path, "w") as f:
                f.write(f"""[Desktop Entry]
Type=Application
Name={self.app_name}
Exec={self.app_path}
Terminal=false
X-GNOME-Autostart-enabled=true
""")
            
            os.chmod(desktop_file_path, 0o755)
            logger.info("Autostart enabled on Linux")
            return True
        except Exception as e:
            logger.error(f"Error enabling autostart on Linux: {e}")
            return False
            
    def _disable_linux(self):
        """Linux'ta masaÃ¼stÃ¼ giriÅŸini kaldÄ±rarak otomatik baÅŸlatmayÄ± devre dÄ±ÅŸÄ± bÄ±rakÄ±r."""
        try:
            desktop_file_path = os.path.expanduser(f"~/.config/autostart/{self.app_name}.desktop")
            if os.path.exists(desktop_file_path):
                os.remove(desktop_file_path)
            logger.info("Autostart disabled on Linux")
            return True
        except Exception as e:
            logger.error(f"Error disabling autostart on Linux: {e}")
            return False
            
    def _is_enabled_linux(self):
        """Linux'ta otomatik baÅŸlatmanÄ±n etkin olup olmadÄ±ÄŸÄ±nÄ± kontrol eder."""
        try:
            desktop_file_path = os.path.expanduser(f"~/.config/autostart/{self.app_name}.desktop")
            return os.path.exists(desktop_file_path)
        except Exception as e:
            logger.error(f"Error checking autostart status on Linux: {e}")
            return False

# --------------------------
# Sistem Tepsisi YÃ¶neticisi
# --------------------------

class TrayManager:
    """Sistem tepsisi simgesini ve menÃ¼sÃ¼nÃ¼ yÃ¶netir."""
    
    def __init__(self, tooltip, icon_data, menu_items=None):
        """
        Tepsi yÃ¶neticisini baÅŸlatÄ±r.
        
        Args:
            tooltip: Ãœzerine gelindiÄŸinde gÃ¶sterilecek araÃ§ ipucu metni
            icon_data: Simge verisi (Base64 veya bytes olarak)
            menu_items: 'text' ve 'command' anahtarlarÄ± olan sÃ¶zlÃ¼kler listesi
        """
        self.tooltip = tooltip
        self.icon_data = icon_data
        self.menu_items = menu_items or []
        self.tray_icon = None
        self.click_handler = None
        
        # Ä°lk kurulumu yap
        self._setup_tray()
        
    def _setup_tray(self):
        """Sistem tepsisi simgesini ayarlar."""
        try:
            # pystray'i iÃ§e aktarmayÄ± dene
            try:
                import pystray
                from PIL import Image
                import io
                
                # MenÃ¼yÃ¼ oluÅŸtur
                def create_menu_items():
                    items = []
                    for item_data in self.menu_items:
                        items.append(pystray.MenuItem(
                            item_data["text"],
                            item_data["command"]
                        ))
                    return items
                
                # PIL gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ al (doÄŸrudan verilebilir veya veriden yÃ¼klenebilir)
                if isinstance(self.icon_data, Image.Image):
                    icon_image = self.icon_data
                else:
                    # Ä°kon verisinden yÃ¼klemeyi dene
                    icon_image = Image.open(io.BytesIO(self.icon_data))
                
                # Simge tÄ±klama iÅŸleyicisi
                def on_icon_click(icon, event):
                    if hasattr(event, 'button'):
                        if event.button == 1 and self.click_handler:  # Sol tÄ±klama
                            self.click_handler()
                    else:
                        # BazÄ± pystray sÃ¼rÃ¼mleri button Ã¶zelliÄŸine sahip deÄŸil
                        if self.click_handler:
                            self.click_handler()
                
                # pystray simgesini oluÅŸtur
                menu = pystray.Menu(*create_menu_items())
                self.tray_icon = pystray.Icon(
                    name=self.tooltip,
                    icon=icon_image,
                    title=self.tooltip,
                    menu=menu
                )
                
                # TÄ±klama olaylarÄ±nÄ± yapÄ±landÄ±r
                self.tray_icon.on_click = on_icon_click
                
                # Arka planda Ã§alÄ±ÅŸtÄ±r
                if hasattr(self.tray_icon, 'run'):
                    threading.Thread(target=lambda: self.tray_icon.run(), daemon=True).start()
            except ImportError as e:
                logger.error(f"pystray or PIL import error: {e}")
                self.tray_icon = None
            
        except Exception as e:
            logger.error(f"Failed to setup tray icon: {e}")
            self.tray_icon = None
            
    def set_click_handler(self, handler):
        """
        Tepsi simgesine tÄ±klandÄ±ÄŸÄ±nda Ã§aÄŸrÄ±lacak iÅŸlevi ayarlar.
        
        Args:
            handler: TÄ±klama Ã¼zerine Ã§aÄŸrÄ±lacak iÅŸlev
        """
        self.click_handler = handler
        
    def update_menu(self, menu_items):
        """
        Tepsi simgesi menÃ¼sÃ¼nÃ¼ gÃ¼nceller.
        
        Args:
            menu_items: 'text' ve 'command' anahtarlarÄ± olan sÃ¶zlÃ¼kler listesi
        """
        self.menu_items = menu_items
        
        # Simgeyi yeniden oluÅŸtur
        if self.tray_icon:
            self.remove()
            self._setup_tray()
            
    def remove(self):
        """Tepsi simgesini kaldÄ±rÄ±r."""
        if self.tray_icon:
            try:
                self.tray_icon.stop()
            except Exception as e:
                logger.error(f"Error removing tray icon: {e}")
            self.tray_icon = None

# --------------------------
# Grafik KullanÄ±cÄ± ArayÃ¼zÃ¼
# --------------------------

class MainApplication(ttk.Frame):
    """Viros Mitm iÃ§in ana uygulama penceresi."""
    
    def __init__(self, master=None):
        """Ana uygulama penceresini baÅŸlatÄ±r."""
        super().__init__(master)
        self.master = master
        
        # Simge ayarla
        self.set_app_icon()
        
        # Stil ve temalar
        self.create_styles()
        
        # DeÄŸiÅŸkenleri oluÅŸtur
        self.create_variables()
        
        # YÃ¶neticileri baÅŸlat
        self.schedule_manager = ScheduleManager(self.scheduled_scan)
        self.notification_manager = NotificationManager("Viros Mitm")
        self.autostart_manager = AutoStartManager("Viros Mitm")
        
        # Pencere ayarlarÄ±
        self.master.title("Viros Mitm - ARP Spoofing Tespit AracÄ±")
        self.master.minsize(800, 600)
        
        # Ana pencere Ã§erÃ§evesi
        self.mainframe = ttk.Frame(self.master, padding="10")
        
        # Pencere iÃ§eriÄŸini oluÅŸtur
        self.create_widgets()
        self.create_layout()
        self.create_bindings()
        
        # Son olarak, sistem tepsisi simgesini oluÅŸtur
        self.create_tray()
        
        # ZamanlayÄ±cÄ± durumunu gÃ¼ncelle
        self.update_schedule_status()
        
        # Otomatik baÅŸlatma durumunu gÃ¼ncelle
        self.autostart_var.set(self.autostart_manager.is_enabled())
        
        # HazÄ±r olduÄŸunda baÅŸlangÄ±Ã§ bildirimi gÃ¶ster
        self.show_tray_notification(
            "Viros Mitm BaÅŸlatÄ±ldÄ±",
            "Viros Mitm ARP Spoofing Tespit AracÄ± baÅŸarÄ±yla baÅŸlatÄ±ldÄ±."
        )
        
        # Ä°lk aÃ§Ä±lÄ±ÅŸta zamanlanmÄ±ÅŸ tarama yapmÄ±yoruz, kullanÄ±cÄ± bunu etkinleÅŸtirebilir
        
    def set_app_icon(self):
        """GÃ¶mÃ¼lÃ¼ kaynaklardan uygulama simgesini ayarlar"""
        # Ä°kon ayarlama iÅŸlemini atlayalÄ±m, uygulama simgesiz Ã§alÄ±ÅŸacak
        pass
    
    def create_variables(self):
        """tkinter deÄŸiÅŸkenlerini oluÅŸturur"""
        # Durum deÄŸiÅŸkenleri
        self.scanning_var = tk.BooleanVar(value=False)
        self.last_scan_time_var = tk.StringVar(value="Son tarama: HiÃ§")
        
        # Zamanlama deÄŸiÅŸkenleri
        self.schedule_interval_var = tk.StringVar(value="1")
        self.schedule_unit_var = tk.StringVar(value="hour")
        
        # Ayarlar deÄŸiÅŸkenleri
        self.autostart_var = tk.BooleanVar(value=False)
        self.show_info_var = tk.BooleanVar(value=True)
        
        # Son sonuÃ§larÄ± sakla
        self.last_result = None
    
    def create_styles(self):
        """Uygulama iÃ§in Ã¶zel stiller oluÅŸturur"""
        style = ttk.Style()
        
        # Renk Paleti
        bg_color = "#f0f0f0"
        accent_color = "#0078d7"
        
        # Font ayarlarÄ±
        default_font = ("Segoe UI", 10)
        header_font = ("Segoe UI", 14, "bold")
        title_font = ("Segoe UI", 16, "bold")

        # Ã–zel stilleri ayarla
        style.configure("Header.TLabel", font=header_font)
        style.configure("Title.TLabel", font=title_font, foreground=accent_color)
        style.configure("StatusGood.TLabel", foreground="green")
        style.configure("StatusWarning.TLabel", foreground="orange")
        style.configure("StatusCritical.TLabel", foreground="red")
        
        # VarsayÄ±lan yapÄ±landÄ±rmalar
        style.configure("TLabel", font=default_font)
        style.configure("TButton", font=default_font)
        style.configure("TCheckbutton", font=default_font)
        
    def create_widgets(self):
        """Uygulama iÃ§in tÃ¼m widget'larÄ± oluÅŸturur"""
        # BaÅŸlÄ±k alanÄ±
        self.header_frame = ttk.Frame(self.mainframe)
        self.title_label = ttk.Label(self.header_frame, text="Viros Mitm", style="Title.TLabel")
        self.subtitle_label = ttk.Label(self.header_frame, text="ARP Spoofing Tespit AracÄ±")
        
        # Eylem butonlarÄ±
        self.action_frame = ttk.Frame(self.mainframe)
        self.scan_button = ttk.Button(self.action_frame, text="AÄŸÄ± Tara", command=self.scan_network)
        self.progress_bar = ttk.Progressbar(self.action_frame, mode="indeterminate", length=200)
        self.last_scan_label = ttk.Label(self.action_frame, textvariable=self.last_scan_time_var)
        
        # Notebook (sekmeli arayÃ¼z)
        self.notebook = ttk.Notebook(self.mainframe)
        
        # SonuÃ§lar sekmesi
        self.results_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.results_tab, text="SonuÃ§lar")
        
        # Ã–zet alanÄ±
        self.summary_frame = ttk.Frame(self.results_tab)
        self.gateway_label = ttk.Label(self.summary_frame, text="VarsayÄ±lan AÄŸ GeÃ§idi: -")
        self.devices_label = ttk.Label(self.summary_frame, text="Bulunan Cihazlar: -")
        self.status_label = ttk.Label(self.summary_frame, text="Durum: AÄŸ henÃ¼z taranmadÄ±")
        
        # SonuÃ§ alanÄ±
        self.results_frame = ttk.Frame(self.results_tab)
        self.results_text = scrolledtext.ScrolledText(self.results_frame, wrap=tk.WORD, width=80, height=20)
        self.results_text.insert(tk.END, "AÄŸÄ± taramak iÃ§in 'AÄŸÄ± Tara' dÃ¼ÄŸmesine tÄ±klayÄ±n.")
        self.results_text.config(state=tk.DISABLED)
        
        # Ayarlar sekmesi
        self.settings_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.settings_tab, text="Ayarlar")
        
        # Zamanlama Ã§erÃ§evesi
        self.schedule_frame = ttk.LabelFrame(self.settings_tab, text="Otomatik Tarama", padding=10)
        self.schedule_label = ttk.Label(self.schedule_frame, 
                                       text="AÄŸÄ± otomatik olarak her ÅŸu zaman diliminde tara:")
        
        # Zamanlama kontrolleri
        self.schedule_controls_frame = ttk.Frame(self.schedule_frame)
        self.schedule_interval_entry = ttk.Spinbox(self.schedule_controls_frame, 
                                                 from_=1, to=24, width=5,
                                                 textvariable=self.schedule_interval_var)
        self.schedule_unit_combo = ttk.Combobox(self.schedule_controls_frame, 
                                               values=["minute", "hour"], 
                                               textvariable=self.schedule_unit_var,
                                               state="readonly", width=10)
        
        # Zamanlama durumu ve kontrolleri
        self.schedule_status_frame = ttk.Frame(self.schedule_frame)
        self.schedule_status_label = ttk.Label(self.schedule_status_frame, 
                                            text="Durum: Zamanlama aktif deÄŸil")
        self.schedule_toggle_button = ttk.Button(self.schedule_status_frame, 
                                               text="ZamanlayÄ±cÄ±yÄ± EtkinleÅŸtir", 
                                               command=self.toggle_scheduling)
        
        # SeÃ§enekler Ã§erÃ§evesi
        self.options_frame = ttk.LabelFrame(self.settings_tab, text="Uygulama AyarlarÄ±", padding=10)
        
        # Otomatik baÅŸlatma seÃ§eneÄŸi
        self.autostart_check = ttk.Checkbutton(self.options_frame, 
                                              text="Bilgisayar aÃ§Ä±ldÄ±ÄŸÄ±nda otomatik baÅŸlat", 
                                              variable=self.autostart_var,
                                              command=self.toggle_autostart)
        
        # GÃ¶rÃ¼ntÃ¼leme seÃ§enekleri
        self.display_frame = ttk.Frame(self.options_frame)
        self.show_info_check = ttk.Checkbutton(self.display_frame, 
                                              text="SonuÃ§larda bilgi Ã¶ÄŸelerini gÃ¶ster", 
                                              variable=self.show_info_var,
                                              command=self.refresh_results)
        
        # Sistem tepsisi seÃ§enekleri
        self.systray_frame = ttk.Frame(self.options_frame)
        self.minimize_to_tray_button = ttk.Button(self.systray_frame, 
                                                 text="Sistem Tepsisinde Ã‡alÄ±ÅŸtÄ±r", 
                                                 command=self.minimize_to_tray)
        
        # HakkÄ±nda sekmesi
        self.about_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.about_tab, text="HakkÄ±nda")
        
        # HakkÄ±nda iÃ§eriÄŸi
        self.about_frame = ttk.Frame(self.about_tab, padding=20)
        self.about_title = ttk.Label(self.about_frame, text="Viros Mitm", style="Header.TLabel")
        self.about_version = ttk.Label(self.about_frame, text="Version 1.0")
        self.about_description = ttk.Label(self.about_frame, 
                                         text="GeliÅŸmiÅŸ ARP Spoofing Tespit AracÄ±", 
                                         wraplength=400)
        self.about_details = ttk.Label(self.about_frame, 
                                      text="Bu araÃ§ aÄŸÄ±nÄ±zÄ± ARP spoofing saldÄ±rÄ±larÄ±na karÅŸÄ± izler. " +
                                           "ARP spoofing, saldÄ±rganlarÄ±n cihazlar arasÄ±ndaki aÄŸ trafiÄŸini " +
                                           "yakalamak iÃ§in kullandÄ±ÄŸÄ± yaygÄ±n bir yÃ¶ntemdir.",
                                      wraplength=400)
        
        # YardÄ±m bÃ¶lÃ¼mÃ¼
        self.help_frame = ttk.LabelFrame(self.about_tab, text="YardÄ±m", padding=10)
        self.help_text = scrolledtext.ScrolledText(self.help_frame, wrap=tk.WORD, 
                                                 width=60, height=10)
        self.help_text.insert(tk.END, """
ARP Spoofing saldÄ±rÄ±larÄ±, saldÄ±rganÄ±n sahte ARP mesajlarÄ± gÃ¶ndererek kendi MAC 
adresini varsayÄ±lan aÄŸ geÃ§idi gibi baÅŸka bir ana bilgisayarÄ±n IP adresi ile 
iliÅŸkilendirdiÄŸinde gerÃ§ekleÅŸir. Bu, o IP adresine gÃ¶nderilmesi gereken trafiÄŸin 
bunun yerine saldÄ±rgana gÃ¶nderilmesine neden olur.

Viros Mitm'i kullanmak iÃ§in:

1. Manuel tarama yapmak iÃ§in "AÄŸÄ± Tara" dÃ¼ÄŸmesine tÄ±klayÄ±n
2. Ayarlar sekmesinde otomatik taramayÄ± yapÄ±landÄ±rÄ±n
3. Viros Mitm'in sistem baÅŸlangÄ±cÄ±nda Ã§alÄ±ÅŸmasÄ± iÃ§in "Bilgisayar aÃ§Ä±ldÄ±ÄŸÄ±nda otomatik baÅŸlat" seÃ§eneÄŸini etkinleÅŸtirin
4. UygulamanÄ±n arka planda Ã§alÄ±ÅŸmasÄ± iÃ§in sistem tepsisine kÃ¼Ã§Ã¼ltÃ¼n

ÅÃ¼pheli bir etkinlik tespit edilirse, Viros Mitm sizi uyarmak iÃ§in uyarÄ±lar ve 
bildirimler gÃ¶sterecektir.
        """)
        self.help_text.config(state=tk.DISABLED)
        
        # Durum Ã§ubuÄŸu
        self.status_bar = ttk.Frame(self.mainframe, relief=tk.SUNKEN)
        self.status_text = ttk.Label(self.status_bar, text="HazÄ±r")
    
    def create_layout(self):
        """Uygulamadaki tÃ¼m widget'larÄ± dÃ¼zenler"""
        # Ana Ã§erÃ§eveyi yapÄ±landÄ±r
        self.mainframe.pack(fill=tk.BOTH, expand=True)
        
        # BaÅŸlÄ±k dÃ¼zeni
        self.header_frame.pack(fill=tk.X, pady=(0, 10))
        self.title_label.pack(side=tk.LEFT)
        self.subtitle_label.pack(side=tk.LEFT, padx=10)
        
        # Eylem butonlarÄ± dÃ¼zeni
        self.action_frame.pack(fill=tk.X, pady=(0, 10))
        self.scan_button.pack(side=tk.LEFT)
        self.progress_bar.pack(side=tk.LEFT, padx=10)
        self.last_scan_label.pack(side=tk.RIGHT)
        
        # Notebook dÃ¼zeni
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # SonuÃ§lar sekmesi dÃ¼zeni
        self.summary_frame.pack(fill=tk.X, padx=5, pady=5)
        self.gateway_label.pack(anchor=tk.W, pady=2)
        self.devices_label.pack(anchor=tk.W, pady=2)
        self.status_label.pack(anchor=tk.W, pady=2)
        
        self.results_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.results_text.pack(fill=tk.BOTH, expand=True)
        
        # Ayarlar sekmesi dÃ¼zeni
        self.schedule_frame.pack(fill=tk.X, padx=5, pady=5)
        self.schedule_label.pack(anchor=tk.W, pady=5)
        
        self.schedule_controls_frame.pack(fill=tk.X)
        self.schedule_interval_entry.pack(side=tk.LEFT, pady=5)
        self.schedule_unit_combo.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.schedule_status_frame.pack(fill=tk.X, pady=5)
        self.schedule_status_label.pack(side=tk.LEFT)
        self.schedule_toggle_button.pack(side=tk.RIGHT)
        
        self.options_frame.pack(fill=tk.X, padx=5, pady=5)
        self.autostart_check.pack(anchor=tk.W, pady=5)
        
        self.display_frame.pack(fill=tk.X, pady=5)
        self.show_info_check.pack(anchor=tk.W)
        
        self.systray_frame.pack(fill=tk.X, pady=5)
        self.minimize_to_tray_button.pack(side=tk.LEFT)
        
        # HakkÄ±nda sekmesi dÃ¼zeni
        self.about_frame.pack(fill=tk.X, padx=5, pady=5)
        self.about_title.pack(anchor=tk.W, pady=(0, 5))
        self.about_version.pack(anchor=tk.W)
        self.about_description.pack(anchor=tk.W, pady=5)
        self.about_details.pack(anchor=tk.W, pady=5)
        
        self.help_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.help_text.pack(fill=tk.BOTH, expand=True)
        
        # Durum Ã§ubuÄŸu dÃ¼zeni
        self.status_bar.pack(fill=tk.X, side=tk.BOTTOM)
        self.status_text.pack(side=tk.LEFT, padx=5, pady=2)
    
    def create_bindings(self):
        """Olay baÄŸlamalarÄ±nÄ± oluÅŸturur"""
        # Pencere kapatma olayÄ±nÄ± baÄŸla
        self.master.protocol("WM_DELETE_WINDOW", self.on_close)
        
        # Sekme deÄŸiÅŸikliÄŸi olayÄ±nÄ± baÄŸla
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
    
    def create_tray(self):
        """Sistem tepsisi simgesini ve menÃ¼sÃ¼nÃ¼ oluÅŸturur"""
        # pystray veya PIL sorunlarÄ±ndan kaÃ§Ä±nmak iÃ§in tray desteÄŸini devre dÄ±ÅŸÄ± bÄ±rakÄ±yoruz
        logger.info("Sistem tepsisi desteÄŸi devre dÄ±ÅŸÄ± bÄ±rakÄ±ldÄ±")
        
        # Tray Ã¶zelliÄŸini atlÄ±yoruz, bu program tray simgesi olmadan Ã§alÄ±ÅŸacak
        pass
    
    def show_window(self):
        """Sistem tepsisinden ana pencereyi gÃ¶sterir"""
        self.master.deiconify()
        self.master.lift()
        self.master.focus_force()
    
    def minimize_to_tray(self):
        """UygulamayÄ± sistem tepsisine kÃ¼Ã§Ã¼ltÃ¼r"""
        try:
            self.master.withdraw()
            # Sadece tepsi simgesi varsa bildirim gÃ¶ster
            if hasattr(self, 'tray_manager') and self.tray_manager:
                self.show_tray_notification(
                    "Viros Mitm Arka Planda",
                    "Uygulama arka planda Ã§alÄ±ÅŸmaya devam ediyor ve aÄŸÄ±nÄ±zÄ± izliyor"
                )
        except Exception as e:
            logger.error(f"Error minimizing to tray: {e}")
    
    def on_close(self):
        """Pencere kapatma olayÄ±nÄ± iÅŸler"""
        if self.schedule_manager.is_active():
            result = messagebox.askyesnocancel(
                "KÃ¼Ã§Ã¼lt veya Ã‡Ä±kÄ±ÅŸ",
                "ZamanlanmÄ±ÅŸ tarama aktif. Ne yapmak istersiniz:\n\n"
                "â€¢ Evet: Sistem tepsisine kÃ¼Ã§Ã¼lt (arka planda Ã§alÄ±ÅŸmaya devam et)\n"
                "â€¢ HayÄ±r: Uygulamadan tamamen Ã§Ä±k\n"
                "â€¢ Ä°ptal: Uygulamaya geri dÃ¶n"
            )
            
            if result is True:  # Evet
                self.minimize_to_tray()
                # UygulamanÄ±n arka planda Ã§alÄ±ÅŸmaya devam edeceÄŸini bildiren bildirim gÃ¶ster
                self.show_tray_notification(
                    "Viros Mitm Arka Planda Ã‡alÄ±ÅŸÄ±yor", 
                    "Uygulama arka planda Ã§alÄ±ÅŸmaya devam edecek ve periyodik taramalarÄ± gerÃ§ekleÅŸtirecek."
                )
                return
            elif result is None:  # Ä°ptal
                return
            # Aksi takdirde (HayÄ±r), uygulama Ã§Ä±kÄ±ÅŸÄ±yla devam et
        
        # Temizle ve Ã§Ä±k
        self.quit_app()
    
    def quit_app(self):
        """Uygulamadan dÃ¼zgÃ¼n bir ÅŸekilde Ã§Ä±kar"""
        # ZamanlayÄ±cÄ±yÄ± durdur
        self.schedule_manager.stop()
        
        # Tepsi simgesini kaldÄ±r
        if hasattr(self, 'tray_manager'):
            self.tray_manager.remove()
        
        # Pencereyi yok et ve Ã§Ä±k
        self.master.destroy()
        sys.exit(0)
    
    def on_tab_changed(self, event):
        """Notebook sekme deÄŸiÅŸikliÄŸi olayÄ±nÄ± iÅŸler"""
        # Sekmeye Ã¶zgÃ¼ eylemler iÃ§in kullanÄ±labilir
        pass
    
    def scan_network(self):
        """ARP spoofing iÃ§in aÄŸÄ± tarar"""
        if self.scanning_var.get():
            # Zaten taranÄ±yor, yeni bir tarama baÅŸlatma
            return
        
        # ArayÃ¼zÃ¼ gÃ¼ncelle
        self.scanning_var.set(True)
        self.scan_button.config(state=tk.DISABLED)
        self.progress_bar.start(10)
        self.status_text.config(text="AÄŸ taranÄ±yor...")
        
        # TaramayÄ± ayrÄ± bir iÅŸ parÃ§acÄ±ÄŸÄ±nda baÅŸlat
        threading.Thread(target=self._perform_scan, daemon=True).start()
    
    def _perform_scan(self):
        """GerÃ§ek ARP taramasÄ±nÄ± ayrÄ± bir iÅŸ parÃ§acÄ±ÄŸÄ±nda gerÃ§ekleÅŸtirir"""
        try:
            # TaramayÄ± gerÃ§ekleÅŸtir
            result = perform_scan()
            
            # SonuÃ§larla arayÃ¼zÃ¼ gÃ¼ncelle
            self.master.after(0, lambda: self.update_scan_results(result))
        except Exception as e:
            logger.error(f"Error during scan: {e}")
            self.master.after(0, lambda: self.scan_error(str(e)))
    
    def update_scan_results(self, result):
        """Tarama sonuÃ§larÄ±yla arayÃ¼zÃ¼ gÃ¼nceller"""
        if not result["success"]:
            self.scan_error(result.get("error", "Unknown error"))
            return
        
        # Son tarama zamanÄ±nÄ± gÃ¼ncelle
        self.last_scan_time_var.set(f"Son tarama: {result['timestamp']}")
        
        # Ã–zeti gÃ¼ncelle
        gateway = result["gateway"]
        self.gateway_label.config(text=f"VarsayÄ±lan AÄŸ GeÃ§idi: {gateway['ip']} (MAC: {gateway['mac']})")
        
        arp_table = result["arp_table"]
        self.devices_label.config(text=f"Bulunan Cihazlar: {len(arp_table)}")
        
        # ÅÃ¼pheli giriÅŸleri kontrol et ve durumu gÃ¼ncelle
        suspicious_entries = result["suspicious_entries"]
        critical_count = result["severity_counts"]["critical"]
        warning_count = result["severity_counts"]["warning"]
        
        if critical_count > 0:
            status_text = f"Durum: âŒ Kritik sorunlar tespit edildi ({critical_count})"
            self.status_label.config(text=status_text, style="StatusCritical.TLabel")
            # Bildirim gÃ¶ster
            self.show_critical_notification(
                "ARP Spoofing SaldÄ±rÄ±sÄ± Tespit Edildi!",
                f"{critical_count} adet kritik sorun tespit edildi. Bu aktif bir saldÄ±rÄ± olabileceÄŸini gÃ¶steriyor."
            )
        elif warning_count > 0:
            status_text = f"Durum: âš ï¸ ÅÃ¼pheli etkinlik tespit edildi ({warning_count})"
            self.status_label.config(text=status_text, style="StatusWarning.TLabel")
            # Bildirim gÃ¶ster
            self.notification_manager.show_notification(
                "ÅÃ¼pheli AÄŸ EtkinliÄŸi",
                f"{warning_count} adet inceleme gerektiren ÅŸÃ¼pheli durum tespit edildi."
            )
        else:
            self.status_label.config(text="Durum: âœ… ÅÃ¼pheli etkinlik tespit edilmedi", 
                                    style="StatusGood.TLabel")
        
        # SonuÃ§ metnini gÃ¼ncelle
        self.display_results(result)
        
        # ArayÃ¼zÃ¼ sÄ±fÄ±rla
        self.scanning_var.set(False)
        self.scan_button.config(state=tk.NORMAL)
        self.progress_bar.stop()
        self.status_text.config(text="Tarama tamamlandÄ±")
    
    def scan_error(self, error_message):
        """Tarama hatalarÄ±nÄ± iÅŸler"""
        # ArayÃ¼zÃ¼ gÃ¼ncelle
        self.scanning_var.set(False)
        self.scan_button.config(state=tk.NORMAL)
        self.progress_bar.stop()
        self.status_text.config(text=f"Hata: {error_message}")
        
        # Hata mesajÄ±nÄ± gÃ¶ster
        messagebox.showerror("Tarama HatasÄ±", f"Tarama sÄ±rasÄ±nda bir hata oluÅŸtu:\n\n{error_message}")
    
    def display_results(self, result):
        """SonuÃ§larÄ± metin alanÄ±nda gÃ¶rÃ¼ntÃ¼ler"""
        self.results_text.config(state=tk.NORMAL)
        self.results_text.delete(1.0, tk.END)
        
        # ARP tablosunu gÃ¶rÃ¼ntÃ¼le
        self.results_text.insert(tk.END, "ARP TABLOSU:\n", "header")
        self.results_text.insert(tk.END, "-" * 60 + "\n")
        self.results_text.insert(tk.END, f"{'IP Adresi':<15} {'MAC Adresi':<20} {'ArayÃ¼z':<10}\n")
        self.results_text.insert(tk.END, "-" * 60 + "\n")
        
        arp_table = result["arp_table"]
        for entry in arp_table:
            self.results_text.insert(tk.END, 
                                     f"{entry['ip']:<15} {entry['mac']:<20} {entry['interface']:<10}\n")
        
        # ÅÃ¼pheli giriÅŸleri gÃ¶rÃ¼ntÃ¼le
        self.results_text.insert(tk.END, "\nANALÄ°Z SONUÃ‡LARI:\n", "header")
        self.results_text.insert(tk.END, "-" * 60 + "\n")
        
        suspicious_entries = result["suspicious_entries"]
        if suspicious_entries:
            displayed_entries = 0
            
            for entry in suspicious_entries:
                # GÃ¶sterilmiyorsa bilgi giriÅŸlerini atla
                if entry.get("severity") == "info" and not self.show_info_var.get():
                    continue
                
                # GiriÅŸi uygun etiketle renklendirerek gÃ¶ster
                severity = entry.get("severity", "info")
                self.results_text.insert(tk.END, entry["message"] + "\n", severity)
                displayed_entries += 1
            
            if displayed_entries == 0:
                self.results_text.insert(tk.END, "Mevcut filtre ayarlarÄ±yla gÃ¶sterilecek sorun yok.\n")
        else:
            self.results_text.insert(tk.END, "âœ… ÅÃ¼pheli etkinlik tespit edilmedi.\n")
        
        # Ã–zeti gÃ¶rÃ¼ntÃ¼le
        self.results_text.insert(tk.END, "\nÃ–ZET:\n", "header")
        self.results_text.insert(tk.END, "-" * 60 + "\n")
        self.results_text.insert(tk.END, f"Toplam cihaz: {len(arp_table)}\n")
        self.results_text.insert(tk.END, f"Kritik sorunlar: {result['severity_counts']['critical']}\n")
        self.results_text.insert(tk.END, f"UyarÄ±lar: {result['severity_counts']['warning']}\n")
        self.results_text.insert(tk.END, f"Bilgi Ã¶ÄŸeleri: {result['severity_counts']['info']}\n")
        
        # Metin stillemesi iÃ§in etiketleri yapÄ±landÄ±r
        self.results_text.tag_configure("header", font=("Segoe UI", 10, "bold"))
        self.results_text.tag_configure("critical", foreground="red")
        self.results_text.tag_configure("warning", foreground="orange")
        self.results_text.tag_configure("info", foreground="blue")
        
        self.results_text.config(state=tk.DISABLED)
    
    def refresh_results(self):
        """SonuÃ§ gÃ¶rÃ¼ntÃ¼lemeyi mevcut filtre ayarlarÄ±yla yeniler"""
        # GÃ¶rÃ¼ntÃ¼lenecek sonuÃ§larÄ±n olup olmadÄ±ÄŸÄ±nÄ± kontrol et
        if hasattr(self, 'last_result'):
            self.display_results(self.last_result)
    
    def update_schedule(self, *args):
        """KullanÄ±cÄ± girdisine gÃ¶re zamanlamayÄ± gÃ¼nceller"""
        # YalnÄ±zca zamanlama etkinse gÃ¼ncelle
        if self.schedule_manager.is_active():
            try:
                interval = int(self.schedule_interval_var.get())
                unit = self.schedule_unit_var.get()
                self.schedule_manager.update(interval, unit)
                self.update_schedule_status()
            except ValueError:
                pass
    
    def toggle_scheduling(self):
        """ZamanlanmÄ±ÅŸ taramayÄ± etkinleÅŸtirir veya devre dÄ±ÅŸÄ± bÄ±rakÄ±r"""
        if self.schedule_manager.is_active():
            # ZamanlamayÄ± devre dÄ±ÅŸÄ± bÄ±rak
            self.schedule_manager.stop()
            self.schedule_toggle_button.config(text="ZamanlayÄ±cÄ±yÄ± EtkinleÅŸtir")
            self.show_tray_notification("ZamanlayÄ±cÄ± Devre DÄ±ÅŸÄ±", 
                                       "Otomatik aÄŸ taramasÄ± devre dÄ±ÅŸÄ± bÄ±rakÄ±ldÄ±")
        else:
            # ZamanlamayÄ± etkinleÅŸtir
            try:
                interval = int(self.schedule_interval_var.get())
                unit = self.schedule_unit_var.get()
                
                # AralÄ±k Ã§ok kÄ±saysa kullanÄ±cÄ±yla onayla
                if unit == "minute" and interval < 5:
                    if not messagebox.askyesno("KÄ±sa Zaman AralÄ±ÄŸÄ±nÄ± Onayla", 
                                              f"Her {interval} dakikada bir tarama yapmak sistem performansÄ±nÄ± etkileyebilir. Devam etmek istiyor musunuz?"):
                        return
                
                self.schedule_manager.start(interval, unit)
                self.schedule_toggle_button.config(text="ZamanlayÄ±cÄ±yÄ± Devre DÄ±ÅŸÄ± BÄ±rak")
                
                # Bildirim gÃ¶ster
                self.show_tray_notification("ZamanlayÄ±cÄ± Aktif", 
                                          f"AÄŸ her {interval} {unit} taranacak")
                
                # KullanÄ±cÄ±nÄ±n tepsi simgesine kÃ¼Ã§Ã¼ltmek isteyip istemediÄŸini sor
                if self.master.winfo_viewable() and messagebox.askyesno("Sistem Tepsisine KÃ¼Ã§Ã¼lt?", 
                                                          "Viros Mitm'i sistem tepsisinde Ã§alÄ±ÅŸmaya devam etmesi iÃ§in kÃ¼Ã§Ã¼ltmek ister misiniz?"):
                    self.minimize_to_tray()
            except ValueError:
                messagebox.showerror("GeÃ§ersiz Zaman AralÄ±ÄŸÄ±", "LÃ¼tfen zaman aralÄ±ÄŸÄ± iÃ§in geÃ§erli bir sayÄ± girin")
        
        self.update_schedule_status()
    
    def update_schedule_status(self):
        """Zamanlama durumu etiketini gÃ¼nceller"""
        if self.schedule_manager.is_active():
            next_run = self.schedule_manager.get_next_run_time()
            self.schedule_status_label.config(
                text=f"Durum: Aktif - Sonraki tarama: {next_run}"
            )
        else:
            self.schedule_status_label.config(text="Durum: Zamanlama aktif deÄŸil")
    
    def scheduled_scan(self):
        """ZamanlanmÄ±ÅŸ taramalar iÃ§in geri Ã§aÄŸÄ±rma"""
        # TaramayÄ± arka planda gerÃ§ekleÅŸtir
        threading.Thread(target=self._scheduled_scan_thread, daemon=True).start()
        
        # Zamanlama durumunu gÃ¼ncelle
        self.master.after(1000, self.update_schedule_status)
    
    def _scheduled_scan_thread(self):
        """ZamanlanmÄ±ÅŸ taramayÄ± ayrÄ± bir iÅŸ parÃ§acÄ±ÄŸÄ±nda Ã§alÄ±ÅŸtÄ±rÄ±r"""
        logger.info("Running scheduled scan")
        
        try:
            # TaramayÄ± gerÃ§ekleÅŸtir
            result = perform_scan()
            
            # Bildirim gÃ¶stermemiz gerekip gerekmediÄŸini kontrol et
            if result["success"]:
                critical_count = result["severity_counts"]["critical"]
                warning_count = result["severity_counts"]["warning"]
                
                if critical_count > 0:
                    # Kritik sorun - bildirim gÃ¶ster
                    self.show_critical_notification(
                        "ARP Spoofing SaldÄ±rÄ±sÄ± Tespit Edildi!",
                        f"{critical_count} adet kritik sorun tespit edildi. Bu aktif bir saldÄ±rÄ± olabileceÄŸini gÃ¶steriyor."
                    )
                elif warning_count > 0:
                    # UyarÄ± - bildirim gÃ¶ster
                    self.notification_manager.show_notification(
                        "ÅÃ¼pheli AÄŸ EtkinliÄŸi",
                        f"{warning_count} adet inceleme gerektiren ÅŸÃ¼pheli durum tespit edildi."
                    )
            
            # Pencere gÃ¶rÃ¼nÃ¼rse gÃ¶rÃ¼ntÃ¼leme iÃ§in sonucu kaydet
            self.last_result = result
            
            # Pencere gÃ¶rÃ¼nÃ¼rse arayÃ¼zÃ¼ gÃ¼ncelle
            if self.master.winfo_viewable():
                self.master.after(0, lambda: self.update_scan_results(result))
        
        except Exception as e:
            logger.error(f"Error during scheduled scan: {e}")
            # YalnÄ±zca pencere gÃ¶rÃ¼nÃ¼rse hatayÄ± arayÃ¼zde gÃ¶ster
            if self.master.winfo_viewable():
                self.master.after(0, lambda: self.scan_error(str(e)))
    
    def toggle_autostart(self):
        """Sistemle birlikte otomatik baÅŸlatmayÄ± deÄŸiÅŸtirir"""
        if self.autostart_var.get():
            # Otomatik baÅŸlatmayÄ± etkinleÅŸtir
            success = self.autostart_manager.enable()
            if not success:
                messagebox.showerror("Hata", "UygulamanÄ±n Windows ile baÅŸlatÄ±lmasÄ± ayarlanamadÄ±")
                self.autostart_var.set(False)
            else:
                messagebox.showinfo("Otomatik BaÅŸlatma Etkin", 
                                   "Viros Mitm artÄ±k Windows ile otomatik olarak baÅŸlayacak")
        else:
            # Otomatik baÅŸlatmayÄ± devre dÄ±ÅŸÄ± bÄ±rak
            success = self.autostart_manager.disable()
            if not success:
                messagebox.showerror("Hata", "Uygulama Windows baÅŸlangÄ±cÄ±ndan kaldÄ±rÄ±lamadÄ±")
                self.autostart_var.set(True)
    
    def show_tray_notification(self, title, message):
        """Sistem tepsisinden bildirim gÃ¶sterir"""
        try:
            if hasattr(self, 'notification_manager') and self.notification_manager:
                self.notification_manager.show_notification(title, message)
        except Exception as e:
            logger.error(f"Error showing notification: {e}")
    
    def show_critical_notification(self, title, message):
        """UyarÄ± sesiyle kritik bir bildirim gÃ¶sterir"""
        try:
            if hasattr(self, 'notification_manager') and self.notification_manager:
                self.notification_manager.show_critical_notification(title, message)
        except Exception as e:
            logger.error(f"Error showing critical notification: {e}")

# --------------------------
# Ana Program
# --------------------------

def main():
    """
    Ana uygulama giriÅŸ noktasÄ±.
    ArayÃ¼zÃ¼ baÅŸlatÄ±r ve uygulamayÄ± baÅŸlatÄ±r.
    """
    # Ä°lk aÃ§Ä±lÄ±ÅŸta eski gÃ¼nlÃ¼kleri temizle
    clean_old_logs()
    
    # YÃ¶netici olarak Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± kontrol et
    if not is_admin():
        logger.warning("Warning: Application not running with administrator privileges")
        # Windows platformunda kullanÄ±cÄ±ya bilgi ver
        if platform.system() == "Windows":
            should_restart = messagebox.askyesno(
                "YÃ¶netici HaklarÄ± Gerekli",
                "Viros Mitm dÃ¼zgÃ¼n Ã§alÄ±ÅŸmak iÃ§in yÃ¶netici haklarÄ±na ihtiyaÃ§ duyar. "
                "SimÃ¼le edilmiÅŸ veriler kullanÄ±lacak ve bazÄ± iÅŸlevler dÃ¼zgÃ¼n Ã§alÄ±ÅŸmayabilir.\n\n"
                "UygulamayÄ± yÃ¶netici olarak yeniden baÅŸlatmak ister misiniz?"
            )
            if should_restart:
                # UygulamayÄ± yÃ¶netici olarak yeniden baÅŸlatmaya Ã§alÄ±ÅŸ
                try:
                    if platform.system() == "Windows":
                        import ctypes, sys
                        ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)
                        sys.exit(0)
                except:
                    messagebox.showerror(
                        "YÃ¶netici Olarak BaÅŸlatÄ±lamadÄ±",
                        "Uygulama yÃ¶netici olarak yeniden baÅŸlatÄ±lamadÄ±. LÃ¼tfen komut istemini yÃ¶netici olarak Ã§alÄ±ÅŸtÄ±rÄ±n ve uygulamayÄ± oradan baÅŸlatÄ±n."
                    )
    
    # Ana uygulama penceresini oluÅŸtur
    root = tk.Tk()
    app = MainApplication(root)
    root.mainloop()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        import traceback
        error_msg = f"Hata: {str(e)}\n\n{traceback.format_exc()}"
        print(error_msg)
        try:
            import tkinter as tk
            from tkinter import messagebox
            root = tk.Tk()
            root.withdraw()
            messagebox.showerror("Viros Mitm - Hata", error_msg)
        except:
            # EÄŸer tkinter kullanÄ±lamÄ±yorsa
            print(error_msg)
            input("Devam etmek iÃ§in Enter tuÅŸuna basÄ±n...")